/*
I do not have branch 2019 yet so this is temporary...
now when i play this day i have 2 problems
1. i do have not have space between cards, hard to say if that is a whole card.  
maybe function dealWithIncrement could be wrong bcs i take first index and that is not the whole number
*/




package Day_22;

import Shared.ReadFile;
import java.util.ArrayList;

public class Solution_1_Day_22 {

	int solution = 0;

//	String deck = createDeck(10); //from 0 to 9
	String deck = createDeck(10007); //from 0 to 10006 

	public int getSolution() {
		ReadFile rf = new ReadFile();
		ArrayList<String> file = new ArrayList<String>();
//		String filepath = "./src/main/resources/Day_22_test_2015.txt";
		String filepath = "./src/main/resources/Day_22_2015.txt";
		file = rf.getInput(filepath);

		//Insert Solution Here:
		for (int i = 0; i < file.size(); i++) {
			String command = file.get(i);
			commandParser(command);

		}
		p(deck);
//		compareResults();
		solution = deck.indexOf("2019");
		return solution;
	}

	public void commandParser(String command) {
		String[] commandParts = command.split(" ");
		switch (commandParts[0]) {
			case "cut":
				cut(Integer.parseInt(commandParts[1]));
				break;
			case "deal":
				if (commandParts[3].equals("stack")) {
					dealIntoNewStack();
				} else {
					dealWithIncrement(Integer.parseInt(commandParts[3]));
				}
				break;
		}
	}

	public void dealIntoNewStack() {
		StringBuilder reverseDeck = new StringBuilder();
		reverseDeck.append(deck);
		reverseDeck.reverse();
		deck = reverseDeck.toString();
	}

	public void cut(int n) {
		if (n < 0) {
			n = deck.length() + n;
		}
		String[] deckParts = {deck.substring(0, n), deck.substring(n)};
		StringBuilder cutDeck = new StringBuilder();
		cutDeck.append(deckParts[1]);
		cutDeck.append(deckParts[0]);
		deck = cutDeck.toString();
	}

	public void dealWithIncrement(int inc) {
		Character firstCard = deck.charAt(0);
		StringBuilder incrementedDeck = new StringBuilder(deck);
		incrementedDeck.setCharAt(0, firstCard);
		int index = 0;
		int deckLength = deck.length();

		for (int i = 1; i < deckLength; i++) {
			index = (inc * i) % deckLength;
			incrementedDeck.setCharAt(index, deck.charAt(i));
		}
		deck = incrementedDeck.toString();
	}

	public String createDeck(int deckLength) {
		StringBuilder createdDeck = new StringBuilder();
		for (int i = 0; i < deckLength; i++) {
			createdDeck.append(i);
		}
		return createdDeck.toString();
	}

	//prints content, System.out.println is way too long
	public void p(Object content) {
		System.out.println(content.toString());
	}

	// ----debug zone----
	public void compareResults() {

		String val1 = "0369258147";
		String val2 = "3074185296";
		String val3 = "6307418529";
		String val4 = "9258147036";

		if (deck.equals(val1)) {
			System.out.println(val1);
		} else if (deck.equals(val2)) {
			System.out.println(val2);
		} else if (deck.equals(val3)) {
			System.out.println(val3);
		} else if (deck.equals(val4)) {
			System.out.println(val4);
		} else {
			System.out.println("Deck does not match any predefined values.");
		}
	}
}
